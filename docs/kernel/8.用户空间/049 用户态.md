# Overview

操作系统肯定是需要进入用户空间的...

# Ring 3

osdev 上是这么说的:

- 设置 用户 gdt entry
- 设置 tss
- 设置 一个中断, 作为系统调用接口 (可选)

---

好了, 现在我们已经在 ring3 了.

但是出现了一个错误: (`#PG`)

这是我之前给自己挖的一个坑, 现在将目光转移到 虚拟内存映射的部分.

```c++
{
    ...
    Tab[Idx] = PE_S_ADDR(New) | PE_RW | PE_P;
    ...
}
```

给用户映射的页表, 除了 PTE 之外的, 它的父表也要打上 `PE_US` 的标记! 直接这么做是非常危险的...

# ?

用户空间的程序, 也是程序, 运行起来, 也就成了一个任务(进程).

在 linux 中, `init` 是所有进程的父进程, 用户所使用的一切, 都是被它或它的后代拉起来的.

```shell
pstree | less
```

在一些 linux 发行版中, 默认的 `init` 是 `systemd`

```txt
systemd-+-bash---sleep
        |-bluetoothd
        |-...
```

## 设计

大概有一个思路了, 现在手头上的 Init 进程是跑在内核的, 它需要负责 初始化文件系统, 这主要是由于 磁盘读写 依赖于任务, 想法是: 在所有的初始化完成之后, Init 加载 init 程序, 进入用户态.

进入用户态使用内联汇编直接 `iret`

> 写完这里后去考证了一下, linux 的设计也是如此...

---

> init 程序的话, 现在什么都没有, 要测试系统功能的话, 还得需要系统调用, 干点什么好呢?
> 做点坏事吧...

```c++
void _start ()
{
    int i = 1 / 0;
    while (1);
}
```

使用它有三个原因:

- 充当 init :)
- 可以测试栈帧
- 在 除零异常 触发后, 在 qemu 控制台输入 `info registers` 来确认当前处理器 CPL, 如果之前的设置没有出错的话 `CPL=0`, 说明当前处理器处于 ring0

